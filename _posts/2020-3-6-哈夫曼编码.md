---
layout: blog
title: 哈夫曼编码
id: 000003
category: blog
description:
published: true
---

## 哈夫曼编码
<mark>有些童鞋有个大误区：哈夫曼编码其实不是一个统一的编码，只不过是编码设计算法而已啦!</mark>

### 编码
#### 前言
先说说编码
电脑手机平板笔记本。。。这一类都是由进制（二）通讯的。
~~就算所谓的基因计算机什么的，也是进制啊，只不过是4进制而已~~
我们要传信，需要一边通过一个函数编码，传到另一边，再解码。~~我也无奈啊计算机只认识0和1，别的都不认识QwQ~~
<div class='mermaid'>
graph TD
A((用户A)) -- 唵嘛嘛嘛嘛呢呢叭咪吽 --&gt; B[function]
B -. Huffman:000101010101111001010011 .-&gt; C[&quot;function&lt;sup&gt;-1&lt;sup/&gt;&quot;]

B -- Traditional:&lt;br&gt;111001011001010010110101 111001011001100010011011 &lt;br&gt;111001011001100010011011 111001011001100010011011 &lt;br&gt;111001011001100010011011 111001011001000110100010 &lt;br&gt;111001011001000110100010 111001011000111110101101 &lt;br&gt;111001011001001010101010 111001011001000010111101 --&gt; C
C -- 唵嘛嘛嘛嘛呢呢叭咪吽 --&gt; D((用户B))
</div>
~~可见哈夫曼比平常的高效多少倍啊……~~
Huffman就想：我们可以画出一颗二叉树（即不放开三胎，每个节点最多生俩），左孩子那条边是0，右孩子是1，每个叶子节点对应一个字符，那么从根节点到一个字符对应的节点那条路，不就是它的编码吗？（很像Trie，但是哈夫曼树只有叶子节点有字符对应）
![二叉树与编码](https://wangzetao.github.io/img/哈夫曼编码/20200305184351333.png)
#### 混淆
问题来了：<mark>会不会发生混淆？</mark>
比如以下编码：

| 字符 | 编码 |
| ---- | ---- |
| a    | 01   |
| b    | 010  |
| c    | 0    |
| d    | 10   |

给你一串编码：010
扫描出来的有：ac、b、cd
到底是啥？不知道啊！在这里面，随机选一个，有$\frac{2}{3}$的风险啊！
发现了吗？有混淆的罪魁祸首莫过于
$$\exists x,y\in C(\text{编码})\\ \exists z;\  x\cdot2^{\lfloor \log_2z\rfloor+1}+z=y$$
简单来说，就是编码里面存在x和y（一对碍眼的daoluaner），x为y的前缀。如果编码里出现了y，岂不是也可能识别出来x？
那么要单独考虑混淆的情况吗？并非如此。Huffman的设计绝对完美，不会出现这种低级卑微的歧义。为什么？
##### ***证明：***
假设树内 存在这样的不巧，那只能一个字是另一个字的子孙喽！
![反证ing](https://wangzetao.github.io/img/哈夫曼编码/20200305204658788.png)
嗯？这个还能叫那棵Huffman想象中的那棵二叉树吗？a那个字不是叶子了！
***-结束证明-***

***

换一个话题
### 哈夫曼树
#### 最小化编码长度
每一位、字节，都是钱，都是资源！
那么，我们要做的就是，让耗资最少，就是让信息越短越好（~~当然不能丢失信息~~），要最省钱￥ω ￥

设根节点深度=0，那么
$$
总耗资=\sum_{i=0}^{n-1} Depth_i\times Freq_i
$$
提几句，这里的freq<sub>i</sub>是i的频率，depth<sub>i</sub>是i的深度。频率这个东西要统计的，数据量越大越好。比如“去”“你”“吃”“饿”都算频率极高的字，比如“寚寜寠寣寭寯寱寴寷”~~（我没一个认识的）~~
这种就算频率几乎为0。

我们发现，深度越深的节点，耗费资源就越多。
频率已经固定了，我们唯一能干的事是改变和交换深度。
总不能把频率最多的放在最深吧？恨不得让它们不费一分钱（~~虽然这个在这个编码里不可能~~）

#### 小故事
举个栗子吧，假设有个人很爱喝橙汁，一天要喝掉几十杯橙汁，一个月累积下来要买几百杯橙汁。这么爱喝橙汁的他，对朴素无味的矿泉水一点兴趣也没有。如果有一天，由他来定矿泉水和橙汁的价格，他肯定会把橙汁定成几乎免费。商店可是要利润的，橙汁都基本免费了，那矿泉水就得多收费了。

同样，哈夫曼编码就像这个人。在最上面那幅图里的“唵嘛嘛嘛嘛呢呢叭咪吽”，“嘛”经常用到，不就像那个人常喝的橙汁吗？而像“唵叭咪吽”，或者甚至有好多这里没提到，如“ABCD”等等等等，不就像他不怎么喝的矿泉水吗？

那么哈夫曼编码跟他的思路一样，像那些常用的字（橙汁），就定的深度浅（价格低）一点。像那些用的少的字（矿泉水），就定的深度深（价格高）一点。由此就可以做出一棵树来，叫做<mark>哈夫曼树</mark>。
![哈夫曼树](https://wangzetao.github.io/img/哈夫曼编码/20200305210740597.png)
只有两个，即橙汁和矿泉水，那简单。现在，变成六个了，怎么办？
~~那个人在考虑拿悬赏换方案~~
要真是这样换的话，我跟他成交，那么我就会告诉他这个算法：
<mark>Huffman Coding</mark>

***
### 构造哈夫曼树
#### 实现方法
哈夫曼树可不一般，要出现也只出现在巫婆家里和电脑里，从叶子生长的。。。
![???](https://wangzetao.github.io/img/哈夫曼编码/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMTkwNTIxL2Y5ZTRlYTBjYzMxYjQ2MTc4NWQ5NTY0NWIyOTBlOWE1LmpwZWc)

 1. 一个节点一棵树，组成森林。
 2. 按频率从小到大排序
 3. 取前两个（就像他不怎么用的矿泉水一样），把它们合并成一棵树。既然它们频率最小，说好的从最深的生长，所以它们应该在最深的叶子那块，所以先合并起来。这棵树的频率变成两棵子树相加的频率。注意一下：合并指新建一个节点，让他左孩子是一棵树，右孩子是另一棵树，就行了。![合并两棵树](https://wangzetao.github.io/img/哈夫曼编码/20200306101936505.png)
 4. 把合并的这棵树插入到该插的地方，使得森林仍然井然有序（由频率排）
 5. 如果森林还有两棵或以上棵树，回到3.，直到只有一棵树。

至此哈夫曼树就构造完了。
<div class='flow'><textarea class='flowcode'>
st=&gt;start: 开始
e=&gt;end: 结束
so=&gt;operation: 构造森林并以频率从小到大排序
op=&gt;operation: 取最小两个
merge=&gt;operation: 合并，频率相加
insert=&gt;operation: 插入到森林，同时不破坏有序性
cond=&gt;condition: 只有一棵树了吗？

st-&gt;so-&gt;op-&gt;merge-&gt;insert-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op
</textarea></div>
![带权哈夫曼树](https://wangzetao.github.io/img/哈夫曼编码/20200306121322567.png)
~~那个人也忒没信用了吧，我都告诉他了方法竟然不给我悬赏钱＞﹏＜~~
#### 代码部分
```java
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.Collections;
import java.util.Comparator;//不一定全
//java
//代码仅供参考，不一定正确，有错误请指正！
class HuffmanTree{
	public int weight;//freq频率
	public char data;//字
	public HuffmanTree lChild,rChild;
	public HuffmanTree(int weight){
		this.weight=weight;
	}
	public HuffmanTree(int weight,char data){
		this.weight=weight;
		this.data=data;
	}
}
public class Huffman{
	public void main(String[] args){
		LinkedList<HuffmanTree> forest=new LinkedList<HuffmanTree>();
		Scanner cin = new Scanner(System.in);
		for(int i=0;i<26;i++){
			System.out.println("字母"+String.format("%c",(char)((int)('a')+i))+"的频率是：");
			forest.add(new HuffmanTree(cin.nextInt(),(char)((int)('a')+i)));//获得每个字母的频率并构造树
		}
		Collections.sort(forest,new Comparator<HuffmanTree>(){//参考：https://blog.csdn.net/pxl20171799/article/details/84474961
			public int compare(HuffmanTree a, HuffmanTree b){                
				return (int) (a.weight-b.weight);             
			}              
		});//排序
		while(forest.size()>1){
			HuffmanTree a = forest.removeFirst();
			HuffmanTree b = forest.removeFirst();//取出前两个
			HuffmanTree c = new HuffmanTree(a.weight+b.weight);//增加新的节点
			c.lChild=a;//连接ac
			c.rChild=b;//连接bc
			int index=0;//用来记录应该插入的位置
			for(Iterator it=forest.iterator();it.hasNext();index++){//遍历
				if(it.next().weight>=c.weight){//看插图↓
					forest.add(index,c);//重新插入树
					break;
				}
			}
		}
	}
}
```
![判别插入位置](https://wangzetao.github.io/img/哈夫曼编码/20200306145126160.png)
##### 生成编解码字典
可以将哈夫曼树遍历一遍，生成编码字典和解码字典。
字典就是这样的：

| 字符 | 编码 |
| ---- | ---- |
| a    | 000  |
| b    | 10   |
| n    | 01   |

如果要利用它来编出banana，找到b，获得10，写下10.
10
然后找到a，获得000，写下000
10000
以此类推
100000100001000
~~这是典型的反哈夫曼编码啊，用的最多的编码最长。。。~~
同样，解码也是这样：

| 编码 | 字符 |
| ---- | ---- |
| 000  | a    |
| 10   | b    |
| 01   | n    |

100000100001000
尝试每一个，发现只有b合适，写下b；
b的编码长度为2，所以从编码开头删两个；
剩下的，尝试每一个，发现只有a合适，写下a；
a的编码长度为3，所以从编码开头删三个；
……
最后得到：banana
~~香蕉就香蕉，我又吃不着，想吃香蕉了。。。~~
###### 编解码字典生成代码
```java
//函数内
HuffmanTree result=forest.get(0);
HashMap<Character,String> CodingMap;
HashMap<String,Character> DecodingMap;
result.dfs(CodingMap,DecodingMap,"");
```

```java
//dfs函数(HuffmanTree类内)
void dfs(HashMap<Character,String> cm,HashMap<String,Character> dm,String prefix){
	int count=0;//记录有几个孩子
	if(lChild!=null){
		lChild.dfs(cm,dm,prefix+"0");
		//左孩子边为0
		count++;//有一个孩子
	}
	if(rChild!=null){
		rChild.dfs(cm,dm,prefix+"1");
		//右孩子边为1
		count++;//有两个孩子
	}
	if(count==0){//一个孩子都没有，叶子节点
		cm.put(data,prefix);
		dm.put(prefix,data);
	}
}
```
prefix可以视为祖传下来的编码，一次往左，往传家宝上写一个0，一次往右，往传家宝上面写一个1.下图中+代表字符串拼接，不是数学加法。
![传家宝](https://wangzetao.github.io/img/哈夫曼编码/20200306153423657.png)
#### 全部代码
```java
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.Collections;
import java.util.Comparator;//不一定全
//代码仅供参考，不一定正确，有错误请指正！
class HuffmanTree{
	public int weight;//freq
	public char data;//字
	public HuffmanTree lChild,rChild;
	public HuffmanTree(int weight){  
	this.weight=weight;
	}
	public HuffmanTree(int weight,char data){  			
		this.weight=weight;  
		this.data=data;
	}
	public void dfs(HashMap<Character,String> cm,HashMap<String,Character> dm,String prefix){  
		int count=0;//记录有几个孩子  
		if(lChild!=null){   
			lChild.dfs(cm,dm,prefix+"0");   
			//左孩子边为0   
			count++;//有一个孩子  
		}  
		if(rChild!=null){   
			rChild.dfs(cm,dm,prefix+"1");   
			//右孩子边为1   
			count++;//有两个孩子  
		}  
		if(count==0){//一个孩子都没有，叶子节点   
			cm.put(data,prefix);   
			dm.put(prefix,data);  
		}
	}
}
public class Huffman{
	public void main(String[] args){  
		LinkedList<HuffmanTree> forest=new LinkedList<HuffmanTree>();  
		Scanner cin = new Scanner(System.in);   
		for(int i=0;i<26;i++){  
 			System.out.println("字母"+String.format("%c",(char)((int)('a')+i))+"的频率是：");   
 			forest.add(new HuffmanTree(cin.nextInt(),(char)((int)('a')+i)));//获得每个字母的频率并构造树  
 		}
 		Collections.sort(forest,new Comparator<HuffmanTree>(){//参考：https://blog.csdn.net/pxl20171799/article/details/84474961   
 			public int compare(HuffmanTree a, HuffmanTree b){                    
 				return (int) (a.weight-b.weight);                
	 		}                
	 	});//排序  
	 	while(forest.size()>1){   
	 		HuffmanTree a = forest.removeFirst();   
	 		HuffmanTree b = forest.removeFirst();//取出前两个   
	 		HuffmanTree c = new HuffmanTree(a.weight+b.weight);//增加新的节点   
	 		c.lChild=a;//连接ac   
	 		c.rChild=b;//连接bc   
	 		int index=0;//用来记录应该插入的位置   
	 		for(Iterator it=forest.iterator();it.hasNext();index++){//遍历    
	 			if(it.next().weight>=c.weight){     
	 				forest.add(index,c);//重新插入树     
	 				break;    
	 			}   
	 		}   
	 		HuffmanTree result=forest.get(0);   
	 		HashMap<Character,String> CodingMap;   
	 		HashMap<String,Character> DecodingMap;   
	 		result.dfs(CodingMap,DecodingMap,"");    
	 		//TODO: 在这里添加编码解码代码：  
	 	}
	 }
}


```
本人小白一枚，有错误请指正！谢谢！
