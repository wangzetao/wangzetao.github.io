---
layout: blog
title: 凸包问题
id: 000004
category: blog
description:
published: true
---

## 凸包问题
什么是凸包？
举个栗子吧
有很多钉子，钉在木板上。拿根猴皮筋，拉的足够大。一松开，“啪”一声，现在的猴皮筋就是凸包
![凸包是什么](https://wangzetao.github.io/img/凸包问题/20200330154217738.png)
呵呵，有点丑。
或者说，让这根猴皮筋尽量小，同时能把所有的钉子包含在内。
怎么求呢？
先插一段：
凸包属于计算几何，计算几何很大程度上基于一个东西，叫做<mark>叉积</mark>。
而且主要用的是判断是在左边还是在右边，叉积>0在左，=0在中，<0在右。

它当然也可以除2算三角形的面积
为什么？
![叉积](https://wangzetao.github.io/img/凸包问题/20200330184342138.png)
这时p2落在了p0->p1的左侧
右侧呢？
只需要交换p1和p2的位置就可以了就可以了。
交换后面积=y1*x2/2-y2*x1/2
	=-原面积
这就是为什么这样了

```python
class Point:
    x=0
    y=0
    @classmethod
    def multi(cls,center,fix,mov):
        x1=fix.x-center.x;y1=fix.y-center.y
        x2=mov.x-center.x;y2=mov.y-center.y
        return x1*y2-x2*y1
```

***
我们直接上算法了。
这个算法需要排序（我也不清楚为什么QwQ）
点排序？难道是字典序？不对。
需要构建一个极坐标系（~~也许我把它说的麻烦了~~），以最下面的点（如有多个取最左边的）为极点，按极角排序。
或者上图吧：
![排序方法](https://wangzetao.github.io/img/凸包问题/20200330185702506.png)
开两个栈，一个存储没发现的（undiscovered），一个存储当前凸包（convex）。
先把0号元素和1号元素入convex。
剩下的入到undiscovered。
![入栈](https://wangzetao.github.io/img/凸包问题/2020033019495639.png)
每一次取出undiscovered栈顶x，convex栈顶y和次顶z
如果x落在z->y左侧，则让z、y回家，同时x也跑到convex家里。
否则，y不属于凸包，只能变成“无栈可归”的乞丐，z回到了convex，x回到了undiscovered
一直重复以上，直到undiscovered为空，convex即为凸包
为什么x跑到右侧y就被害（成乞丐）了呢？
![原因](https://wangzetao.github.io/img/凸包问题/20200330220748764.png)
## 代码
~~请不要觉得快完了。~~
![凸包代码效果](https://wangzetao.github.io/img/凸包问题/20200331085714389.gif)
注释：后来觉得慢，在里面加入了tracer相关代码，下面附上改进后的效果：
![改进后](https://wangzetao.github.io/img/凸包问题/20200331220356969.gif)
```python
import turtle
from queue import *
from functools import cmp_to_key
turt=turtle.Turtle()
scr=turtle.Screen()
class Point:
    x=0
    y=0
    @classmethod
    def multi(cls,center,fix,mov):
        x1=fix.x-center.x;y1=fix.y-center.y
        x2=mov.x-center.x;y2=mov.y-center.y
        return x1*y2-x2*y1
points=[]
ltl=Point()
first=True
undoing=0
def convexHull():
    #region pre
    #region globals
    global points
    global undoing
    #endregion
    print(ltl.x,ltl.y)
    p=points[0]
    # for sub,i in enumerate(points):
    #     if i.x==ltl.x and i.y == ltl.y:
    #         points[sub]=p
    #         points[0]=ltl

    points[1:]=sorted(points[1:],
        key=cmp_to_key(
            lambda x,y:Point.multi(ltl,y,x)
        )
    )
    #endregion
    if len(points) >= 3:
        #region convex
        #region mid
        convex=LifoQueue()
        undiscovered=LifoQueue()
        convex.put(ltl)
        convex.put(points[1])
        for i in points[:1:-1]:
            undiscovered.put(i)
        #endregion
        while not undiscovered.empty():
            convextop=convex.get()
            convexsecondary=convex.get()
            udcdtop=undiscovered.get()
            if Point.multi(convexsecondary,convextop,udcdtop) > 0:
                convex.put(convexsecondary);convex.put(convextop);convex.put(udcdtop)
            else:
                convex.put(convexsecondary);undiscovered.put(udcdtop)
        top=convex.get()
        bot=top
        while not convex.empty():
            t=convex.get()
            turt.penup();turt.goto(t.x, t.y);turt.pendown()
            turt.goto(bot.x, bot.y)
            bot=t
            undoing+=4
        turt.penup();turt.goto(top.x, top.y);turt.pendown()
        turt.goto(bot.x, bot.y)
        undoing+=4

        #endregion

    pass

lastUndoCap=0
def getpos(x,y):
    #region globals
    global lastUndoCap
    global first
    global points
    global undoing
    #endregion
    isLtl=False
    if first:
        ltl.x=x;ltl.y=y
        isLtl=True
    else:
        if y < ltl.y:
            ltl.x = x
            ltl.y = y
            isLtl = True
        elif y == ltl.y:
            if x < ltl.x:
                ltl.x = x
                ltl.y = y
                isLtl = True
    first=False
    turtle.tracer(False)
    # while turt.undobufferentries() != lastUndoCap:
    #     turt.undo()
    for i in range(0,undoing):
        turt.undo()
    undoing=0
    turtle.tracer(True)

    print("%d %d",x,y)
    turt.penup();turt.goto(x, y)
    radii=1
    turt.left(90);turt.backward(radii);turt.right(90)
    turt.begin_fill();turt.pendown();turt.color("blue");turt.circle(radii);turt.end_fill()
    point=Point()
    point.x=x;point.y=y
    if isLtl:
        points.insert(0,point)
    else:
        points.append(point)
    lastUndoCap=turt.undobufferentries()
    turtle.tracer(False)
    convexHull()
    turtle.tracer(True)


turt.hideturtle();turtle.delay(0)
lastUndoCap=turt.undobufferentries()
scr.onclick(getpos)
turtle.done()


```
呵呵，代码不算好，我在代码里每次都重算，到后面就显得慢了（tracer也压不住啊），如果要搞这种递增的算法，还是建议换一个。
另外，如果假设一个点在$-\infin$处，这时候按照极角排序就变成了按照x从右边到左边排序，最后获得的凸包是上凸壳（就是最左边的点到最右边的点，在这两个地方把凸包剪开，上面的就是上凸壳）。
上图吧
![上凸壳](https://wangzetao.github.io/img/凸包问题/20200807105555913.png)
如果是假设有一个点在$+\infin$处，那么就变成了从右往左边排序，这个时候类似的得到的就是下凸壳。
![下凸壳](https://wangzetao.github.io/img/凸包问题/202008071100292.png)
把两个凸壳拼起来就是凸包了。
酱终于没有极角的那些捣乱了，ε=ε=ε=(\~￣▽￣)\~
上面算法复杂度：mnlogn，m为次数，n为点数。要只有一次，建议使用上述算法。

***
下面算法复杂度：n^2，n为点数。在多次递增时体现优势，在一次时略差。
首先开始3个点，一定是凸包。
<mark>每一个点要记录顺着自己逆时针走到的第一个点ccw和顺时针走到的cw。</mark>
每一次我们要将局部解扩张到更大的局部解。
新进来一个点，可能是凸包，可能不是，也可能自己是了同时有点又不是了。。。
怎么弄呢？举个栗子吧。
某某某年，人类航天技术极度繁荣，准备探索a系。我们把飞船建在了一颗小行星（局部解）上，然后飞往a系。为了探索需要，每一个飞船角需要建立一个“灯塔”（凸包上的点）。进入a系后，发现恒星（新进来的点）也是光源。而阳光把小行星分成了阴阳两面。有人就想：可以把这颗恒星变成灯塔（技术允许），然后把a系小行星带召唤过来，拼一拼，不就构成了个更大的小行星（更大的局部解）吗？同时为了省电，不露出来的灯塔（不属于新凸包的点）就要拆掉。现在灯塔很多，人有眼而不得算之，机器可以算，机器的眼睛呢？总不能把人眼拆下来吧。。。
仔细想一想就知道，要拆掉阳面（不包括分界点）的灯塔。
~~画布背景变黑是因为要模拟太空~~
![拆掉哪些灯塔](https://wangzetao.github.io/img/凸包问题/20200331140250912.png)
那怎么去计算呢？阴阳切点的现象有什么区别？
我们暂且把灯塔化成指向这个点的ccw点的箭头
![加箭头](https://wangzetao.github.io/img/凸包问题/20200331141304516.png)
发现了吗？阳面箭头朝下，阴面箭头朝上，切点箭头朝左右。
我们可以这样判断，随便找到一个灯塔，把自己的位置记为M。设恒星为S。
让R为自己的ccw，L为自己的cw，做这样的判断：

 1. l在S->M线左侧，r在S->M线右侧，M在阳面![阳](https://wangzetao.github.io/img/凸包问题/20200331145848401.png)
 2. l在S->M线右侧，r在S->M线左侧，M在阴面![阴](https://wangzetao.github.io/img/凸包问题/20200331162146337.png)
 3. l,r都在S->M线左侧，M在切点1![切点1](https://wangzetao.github.io/img/凸包问题/20200331162223783.png)
 4. l,r都S->M线右侧，M在切点2![切点2](https://wangzetao.github.io/img/凸包问题/2020033116224923.png)

如果是切点，记下来。
然后逆时针走一格。
如此往复，直到走完了一圈，就可以来把恒星变灯塔和召唤小行星带了。
那这一步怎么做呢？很简单，只需要：
S.cw=切点2
切点2.ccw=S
S.ccw=切点1
切点1.cw=S
而这一步就像链表删除一样。那些灯塔，尽管已经不再小行星内了，但它们自己还连在一起。
现在一个更大的飞船造出来了，就可以去探访下一个星系b系了。
等等？似乎还有一个问题。万一恒星跑到小行星里面怎么办？（其实现实不允许啦。）
你会发现：
![戴森球](https://wangzetao.github.io/img/凸包问题/20200331172645169.png)
这个小行星就成戴森球了。
对应的现实就是不把它算作凸包点，就算把它变成灯塔，也要拆掉，又何必呢？
## 代码2
![小行星算法](https://wangzetao.github.io/img/凸包问题/20200331220850804.gif)
```python
import turtle
from queue import *
from functools import cmp_to_key
turt=turtle.Turtle()
scr=turtle.Screen()
class Point:
    x=0
    y=0
    def __init__(self):
        self.ccw=self.cw=None
    @classmethod
    def multi(cls,center,fix,mov):
        x1=fix.x-center.x;y1=fix.y-center.y
        x2=mov.x-center.x;y2=mov.y-center.y
        return x1*y2-x2*y1
    def copy(self):
        a=Point()
        a.x=self.x
        a.y=self.y
        a.ccw=self.ccw
        a.cw=self.cw
        return a
points=[]
ltl=Point()
first=True
lastUndoCap=0
undoing=0
def ncp(a,b):
    points[a].ccw=points[b]
    points[b].cw=points[a]
def getpos(x,y):
    #region globals
    global lastUndoCap
    global first
    global points
    global undoing
    #endregion
    isLtl=False
    if first:
        ltl.x=x;ltl.y=y
        isLtl=True
    else:
        if y < ltl.y:
            ltl.x = x
            ltl.y = y
            isLtl = True
        elif y == ltl.y:
            if x < ltl.x:
                ltl.x = x
                ltl.y = y
                isLtl = True
    first=False
    turtle.tracer(False)
    # while turt.undobufferentries() != lastUndoCap:
    #     turt.undo()
    for i in range(0,undoing):
        turt.undo()
    undoing=0
    turtle.tracer(True)
    print("%d %d",x,y)
    turt.penup();turt.goto(x,y)
    radii=1
    turt.left(90);turt.backward(radii);turt.right(90)
    turt.begin_fill();turt.pendown();turt.color("blue");turt.circle(radii);turt.end_fill()
    point=Point()
    point.x=x;point.y=y
    if isLtl:
        points.insert(0,point)
    else:
        points.append(point)
    lastUndoCap=turt.undobufferentries()
    #region convex
    if len(points) == 3:
        left=(0<Point.multi(points[0],points[1],points[2]))
        if left:
            ncp(0,1)
            ncp(1,2)
            ncp(2,0)
        else:
            ncp(0,2)
            ncp(2,1)
            ncp(1,0)
    elif len(points) > 3:
        p=Point()
        orisub=0
        if isLtl:
            p=points[1]
            orisub=1
        else:
            p=points[0]
            orisub=0
        st=p.copy()
        sun=point
        q1=None
        q2=None
        while True:
            p=p.ccw
            l=p.cw
            r=p.ccw
            ll=(0 < Point.multi(sun,p,l))
            rl=(0 < Point.multi(sun,p,r))
            if ll == rl:
                if ll:
                    q1=p
                else:
                    q2=p
            if p.x==st.x and p.y==st.y:
                break
        if q1 is not None:
            sun.cw = q2
            q2.ccw = sun
            sun.ccw = q1
            q1.cw = sun
    if len(points) >= 3:
        turt.penup();turt.goto(points[0].x,points[0].y);turt.pendown()
        undoing+=3
        it=points[0].copy()
        turtle.tracer(False)
        while True:
            turt.goto(it.ccw.x,it.ccw.y)
            undoing+=1
            it=it.ccw.copy()
            if it.x==points[0].x and it.y==points[0].y:
                break
        turtle.tracer(True)





    #endregion


turt.hideturtle();turtle.delay(0)
lastUndoCap=turt.undobufferentries()
scr.onclick(getpos)
turtle.done()


```
